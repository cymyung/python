list(목록) 자료형 - 순차적 접근 자료형

 index       0      1      2          -1
 변수 = [원소1, 원소2, 원소3, ..., 원소n]
        [item1, item2, item3, ..., itemn]

 인덱싱(indexing) : 목록안에 있는 특정한 원소(데이터) 1개를 조회하는 기법
 사용법 - 변수[index]	->	원소, item
          변수[0]	->	원소1, item1
          변수[2]	->	원소3, item3
          변수[-1]	->	원소n, itemn

 슬라이싱(slicing) : 목록안에 있는 연속적인 원소(데이터)들을 조회하는 기법
 사용법 - 변수[start:end]	-> start 이상부터 end 미만 사이의 원소들을 조회
				   start 생략시 0 index이상부터
				   end   생략시 마지막 index까지

          index           0     1        2      3   4   5   6   7
          student = ['홍길동', 'A', '구로동',  80, 90, 88, 85, 90]

          student[0]	-> 'hong'
          student[0:3]	-> ['홍길동', 'A', '구로동']
          student[:3]	-> ['홍길동', 'A', '구로동']
          student[3:8]	-> [80, 90, 88, 85, 90]
          student[3:]	-> [80, 90, 88, 85, 90]
          student	-> ['홍길동', 'A', '구로동',  80, 90, 88, 85, 90]
          student[:]	-> ['홍길동', 'A', '구로동',  80, 90, 88, 85, 90]

 목록형 데이터 관련된 함수들
  변수.append(값)	: 목록뒤에 값을 추가
  변수.insert(idx, 값)	: 목록안에 값을 특정한 위치(index)에 삽입, 그 자리에 있던
			  원래의 값(원소)는 1칸 뒤로 밀림
  변수.remove(값)	: 목록안에 동일한 값을 제거, 여러개가 있는 경우
			  가장 앞쪽의 값을 제거
  del 변수[idx]		: 목록안에 특정한 위치(index)의 값을 제거
  변수.extend(목록)	: 목록뒤에 새목록을 확장

  변수.count(값)	: 동일한 값이 몇개가 있는가?
  변수.index(값)	: 특정한 값의 index는?

  변수.sort()		: 원본(목록)을 오름차순으로 정렬한다.(반환값 X)
  변수.reverse()	: 원본(목록)을 역순으로 정렬한다. (반환값 X, 내림차순 X)


 변수에 저장된 데이터가 여러개의 값들 중 1개와 일치하는지를 검사하는 코드
  -> 결과 [True / False]

   1. 조건 or 조건
      변수 == '값1' or 변수 == '값2' or 변수 == '값3' or ...

   2. 변수 in 목록 : 목록안에 원소들을 중 변수의 값과 일치하는 원소가 있는가?
      변수 in ['값1', '값2', '값3', ...]


튜플(tuple)형 자료
  - 목록(list)형 자료와 유사한 자료형으로써 목록과 사용방법은 동일하지만,
    원소들을 추가하거나 변경을 할 수 없는 자료형이다.
    자료를 생성한 후에 변경할 수 없도록 보호하기 위해서 사용한다.

    목록에서 사용한 함수들 중
     사용 가능한 함수   - count(), index()
     사용 불가능한 함수 - append(), insert(), remove(), sort(), reverse()


 목록(list) , 튜플(tuple) - 순서형(sequence) 자료형, 순서에 매우 민감한 자료형
 사전(dict) , 셋(set)     - 비순서형(random) 자료형, 순서가 상관없는 자료형



사전(dict)형 자료 - 비순차적(임의의) 접근 자료형

 변수 = { 키1: 값1   ,  키2: 값2   ,  키3: 값3   ,  ...}
        {key1: value1, key2: value2, key3: value3,  ...}
         <---item1-->  <---item2-->  <---item3-->

  ※ key는 value를 사용하기 위해 사용되는 메타데이터로써
     value를 가장 잘 나타낼 수 있는 데이터를 사용한다.

 조회: 변수[키]		-> 값
       변수[키1]	-> 값1
       변수[키3]	-> 값3
       변수[key2]	-> value2

 사전형 데이터 관련된 함수들
   변수.keys()		-> 사전형 자료에서 key들을 목록화
			   [key1, key2, key3, ...]
   변수.values()	-> 사전형 자료에서 value들을 목록화
			   [value1, value2, value3, ...]
   변수.items()		-> 사전형 자료에서 (key, values) 튜플을 묶고, 전체를 목록화
			   [(key1, value1), (key2, value2), (key3, value3), ...]
   변수.get(key [, default])	-> 사전에서 key가 있으면 value를 출력하고,
				            key가 없으면 default(대체값)을 출력한다.

    >>> scores = {'kor':80, 'eng':90, 'math':85}

    >>> scores['kor']		-> 80
    >>> scores['sci']		-> 에러(KeyError) 발생, 없는 Key를 조회할 경우 에러
    >>> scores.get('kor', 0)	-> 80, 'kor'의 값 출력
    >>> scores.get('sci', 0)	->  0, 'sci' 키가 없으면 대체값으로 출력



변수명의 규칙
  1. 0 ~ 9, A ~ Z, a ~ z, _ 만으로 구성할 수 있다.
  2. 0 ~ 9(숫자)로 시작할 수 없다.
  3. 시스템 예약어는 사용할 수 없다.
       -> for, while, if, in, not, True, False, ...

사용할 수 없는 변수명
  1kor, 2eng	: 0 ~ 9(숫자)로 시작할 수 없다.
  my average	: 띄어쓰기는 사용할 수 없다.
  rate%		: % 특수문자는 사용할 수 없다.
  for, while	: 시스템 예약어는 사용할 수 없다.

사용할 수 있지만, 추천하지 않는 변수명
  e, s, ty, og	: 너무 짧은 변수명
  dfegyh	: 아무 의미없이 조합된 변수명
  sum, max	: 내장 함수

추천하는 변수명 : 너무 짧지 않고, 변수명만으로도 저장된 값을 유추
  city, name, average, kor, eng, index(idx), index(i), number(n), ...

2개이상의 단어를 조합하여 변수명을 만들 때
 snake_case : my_average, [Python] 일반적인 변수명을 만들 때 사용한다.
 PascalCase : MyAverage , 클래스명 만들 때 사용한다.
 camelCase  : myAverage , [C,C++,Java] 일반적인 변수명을 만들 때 사용한다.

